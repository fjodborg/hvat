//! Bitmap font rendering for test hyperspectral images.

/// 5x7 bitmap font for text rendering.
fn get_char_bitmap(c: char) -> Option<[u8; 7]> {
    match c {
        'A' => Some([0b01110, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001]),
        'B' => Some([0b11110, 0b10001, 0b10001, 0b11110, 0b10001, 0b10001, 0b11110]),
        'C' => Some([0b01110, 0b10001, 0b10000, 0b10000, 0b10000, 0b10001, 0b01110]),
        'D' => Some([0b11110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b11110]),
        'E' => Some([0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b11111]),
        'F' => Some([0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b10000]),
        'G' => Some([0b01110, 0b10001, 0b10000, 0b10111, 0b10001, 0b10001, 0b01110]),
        'H' => Some([0b10001, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001]),
        'I' => Some([0b11111, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b11111]),
        'L' => Some([0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b11111]),
        'M' => Some([0b10001, 0b11011, 0b10101, 0b10101, 0b10001, 0b10001, 0b10001]),
        'N' => Some([0b10001, 0b11001, 0b10101, 0b10101, 0b10011, 0b10011, 0b10001]),
        'O' => Some([0b01110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110]),
        'P' => Some([0b11110, 0b10001, 0b10001, 0b11110, 0b10000, 0b10000, 0b10000]),
        'R' => Some([0b11110, 0b10001, 0b10001, 0b11110, 0b10100, 0b10010, 0b10001]),
        'S' => Some([0b01111, 0b10000, 0b10000, 0b01110, 0b00001, 0b00001, 0b11110]),
        'T' => Some([0b11111, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100]),
        'U' => Some([0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110]),
        'X' => Some([0b10001, 0b10001, 0b01010, 0b00100, 0b01010, 0b10001, 0b10001]),
        'Y' => Some([0b10001, 0b10001, 0b01010, 0b00100, 0b00100, 0b00100, 0b00100]),
        '0' => Some([0b01110, 0b10001, 0b10011, 0b10101, 0b11001, 0b10001, 0b01110]),
        '1' => Some([0b00100, 0b01100, 0b00100, 0b00100, 0b00100, 0b00100, 0b01110]),
        '2' => Some([0b01110, 0b10001, 0b00001, 0b00110, 0b01000, 0b10000, 0b11111]),
        '3' => Some([0b01110, 0b10001, 0b00001, 0b00110, 0b00001, 0b10001, 0b01110]),
        '4' => Some([0b00010, 0b00110, 0b01010, 0b10010, 0b11111, 0b00010, 0b00010]),
        '5' => Some([0b11111, 0b10000, 0b11110, 0b00001, 0b00001, 0b10001, 0b01110]),
        '6' => Some([0b01110, 0b10000, 0b11110, 0b10001, 0b10001, 0b10001, 0b01110]),
        '7' => Some([0b11111, 0b00001, 0b00010, 0b00100, 0b01000, 0b01000, 0b01000]),
        '8' => Some([0b01110, 0b10001, 0b10001, 0b01110, 0b10001, 0b10001, 0b01110]),
        '9' => Some([0b01110, 0b10001, 0b10001, 0b01111, 0b00001, 0b00001, 0b01110]),
        '!' => Some([0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b00000, 0b00100]),
        '.' => Some([0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00100]),
        ' ' => Some([0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000, 0b00000]),
        _ => None,
    }
}

/// Render test image text centered in the image.
///
/// Returns a pixel intensity value (0.0-1.0) for the given coordinates.
pub fn render_test_text(x: u32, y: u32, width: u32, height: u32) -> f32 {
    let lines = [
        "AUTOGENERATED",
        "HYPERSPECTRAL IMAGE",
        "TRY SETTING",
        "DIFFERENT BANDS!",
    ];
    let char_width: u32 = 5;
    let char_height: u32 = 7;
    let char_spacing: u32 = 1;
    let line_spacing: u32 = 8;
    let scale: u32 = 8;

    let scaled_char_width = char_width * scale;
    let scaled_char_height = char_height * scale;
    let scaled_char_spacing = char_spacing * scale;
    let scaled_line_spacing = line_spacing * scale;

    let max_line_len = lines.iter().map(|l| l.len()).max().unwrap_or(0);
    let total_width = max_line_len as u32 * (scaled_char_width + scaled_char_spacing);
    let total_height = lines.len() as u32 * (scaled_char_height + scaled_line_spacing);

    let start_x = (width.saturating_sub(total_width)) / 2;
    let start_y = (height.saturating_sub(total_height)) / 2;

    if x < start_x || y < start_y {
        return 0.0;
    }

    let rel_x = x - start_x;
    let rel_y = y - start_y;

    let line_height = scaled_char_height + scaled_line_spacing;
    let line_idx = (rel_y / line_height) as usize;
    if line_idx >= lines.len() {
        return 0.0;
    }

    let line = lines[line_idx];
    let line_y = rel_y % line_height;

    if line_y >= scaled_char_height {
        return 0.0;
    }

    let line_width = line.len() as u32 * (scaled_char_width + scaled_char_spacing);
    let line_start_x = (total_width.saturating_sub(line_width)) / 2;

    if rel_x < line_start_x {
        return 0.0;
    }

    let line_rel_x = rel_x - line_start_x;

    let char_total_width = scaled_char_width + scaled_char_spacing;
    let char_idx = (line_rel_x / char_total_width) as usize;
    if char_idx >= line.len() {
        return 0.0;
    }

    let char_x = line_rel_x % char_total_width;

    if char_x >= scaled_char_width {
        return 0.0;
    }

    let c = match line.chars().nth(char_idx) {
        Some(c) => c,
        None => return 0.0,
    };
    let bitmap = match get_char_bitmap(c) {
        Some(b) => b,
        None => return 0.0,
    };

    let bx = (char_x / scale) as usize;
    let by = (line_y / scale) as usize;

    if by < 7 && bx < 5 {
        let row = bitmap[by];
        let bit = (row >> (4 - bx)) & 1;
        if bit == 1 {
            return 1.0;
        }
    }

    0.0
}
